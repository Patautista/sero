@page "/anki"

@using ApplicationL
@using ApplicationL.ViewModel
@using Domain
@using System.Text
@attribute [StreamRendering(true)]

@inject CardService Api

<PageTitle>Frases Anki</PageTitle>

<h1>Frases Anki</h1>

@if (cards == null)
{
    <p><em>Loading...</em></p>
}
else
@if (currentCard != null)
{
    <div class="card p-4 mb-3" style="max-width: 600px;">
        <h5>Traduza para a língua alvo:</h5>
        <p class="mb-3"><strong>@currentCard.Card.NativeSentence.Text</strong></p>

        @if (currentCard.Card.Tags != null && currentCard.Card.Tags.Any())
        {
            <p class="mb-3 text-muted">
                Tags: @string.Join(", ", currentCard.Card.Tags.Select(t => t.Name))
            </p>
        }

        @if (currentCard.State.Repetitions == 0)
        {
            <!-- First time seeing card: show answer -->
            <p class="alert alert-info">
                Novo card! Resposta: <strong>@currentCard.Card.TargetSentence.Text</strong>
            </p>
        }
        <!-- Normal flow -->
        <input class="form-control mb-2" @bind="userAnswer" placeholder="Type your answer" />
        <button class="btn btn-primary mb-2" @onclick="CheckAnswer">Check</button>

        @if (validationMessage != null)
        {
            <p class="mt-2" style="color:@(isCorrect ? "green" : "red")">@validationMessage</p>
        }

        <button class="btn btn-secondary mt-2" @onclick="NextSentence">Next</button>
        <DictCcSearch></DictCcSearch>
        <ConjugationLookup></ConjugationLookup>
    </div>
}


@code {
    private ICollection<CardWithState> cards;
    private CardWithState currentCard;
    private string userAnswer;
    private string validationMessage;
    private bool isCorrect;

    protected override async Task OnInitializedAsync()
    {
        cards = await Api.GetCards();
        NextSentence();
    }

    private void NextSentence()
    {
        if (cards == null || !cards.Any()) return;

        // Pick a random sentence for simplicity
        var rnd = new Random();
        currentCard = cards.ElementAt(rnd.Next(cards.Count));
        userAnswer = string.Empty;
        validationMessage = null;
        isCorrect = false;
    }

    private async Task CheckAnswer()
    {
        if (string.IsNullOrWhiteSpace(userAnswer)) return;

        var possibleAnswers = new List<string> { currentCard.Card.TargetSentence.Text };

        var evaluation = AnswerEvaluator.Evaluate(userAnswer, possibleAnswers);

        isCorrect = evaluation.Quality != AnswerQuality.Wrong;

        Srs.Review(currentCard.State, (int)evaluation.Quality);

        // Display feedback
        validationMessage = BuildFeedbackMessage(evaluation);

        // Save state
        await Api.UpdateUserCardState(currentCard.State);
    }

    private string BuildFeedbackMessage(AnswerEvaluation evaluation)
    {
        var sb = new StringBuilder();

        if (evaluation.Quality > AnswerQuality.Wrong)
        {
            sb.Append("✅ Correto!");
        }
        else if (evaluation.Quality == AnswerQuality.Wrong)
        {
            sb.Append("❌ Tente de novo.");
        }

        if (evaluation.Quality < AnswerQuality.Perfect)
        {
            sb.Append($" Resposta mais próxima: {evaluation.ClosestMatch}");
        }

        return sb.ToString();
    }
}
