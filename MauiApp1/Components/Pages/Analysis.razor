@page "/analysis"
@page "/analysis/{EncodedText}"
@page "/analysis/{EncodedText}/{EncodedTranslation}"
@using System.Globalization
@using Business.Interfaces
@using Infrastructure.Factories
@using Infrastructure.Services
@using Infrastructure.Vocab
@using MauiApp1.Components.Shared
@using MauiApp1.Services
@using MauiApp1.Services.Audio
@inject IJSRuntime JS
@inject ISettingsService SettingsService
@inject ApiService ApiService
@inject NavigationManager Navigation
@inject MauiSoundService SoundService
@inherits SmartComponent

<div class="card-creation-container p-6 bg-white rounded-lg shadow-lg max-w-2xl mx-auto mb-4">
    <h2 class="text-2xl font-bold mb-6 text-indigo-700"><Translate Text="Análise de Texto"></Translate></h2>

    <!-- Input Section - Only show if no text is being analyzed -->
    @if (string.IsNullOrWhiteSpace(analysisText) && !isAnalyzing)
    {
        <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-2">
                <Translate Text="Texto para análise"></Translate>
            </label>
            <AutoResizeTextArea Value="@inputText"
                                ValueChanged="@((string val) => { inputText = val; StateHasChanged(); })"
                                Id="analysisInput"
                                CssClass="w-full p-2 border rounded-lg focus:ring-2 focus:ring-indigo-500"
                                Placeholder="@Translate("Digite ou cole o texto em " + TargetLanguage?.DisplayName)"
                                MinRows="3"
                                MaxLength="500" />
        </div>

        <div class="flex justify-center mb-4">
            <ButtonPrimary OnClick="StartAnalysis" Disabled="@string.IsNullOrWhiteSpace(inputText)">
                <i class="fa fa-search me-2"></i>
                <Translate Text="Analisar"></Translate>
            </ButtonPrimary>
        </div>
    }
    else
    {
        <!-- Definition Display Area -->
        @if (selectedItem != null && !string.IsNullOrWhiteSpace(selectedItem.AiInsight.Chunk))
        {
            <div class="mb-4 p-4 bg-blue-50 rounded-lg border border-blue-200">
                <div class="d-flex justify-content-between align-items-start mb-2">
                    <div class="d-flex gap-2 align-items-center flex-wrap">
                        <h4 class="text-lg font-semibold text-blue-800 mb-0">@selectedItem.AiInsight.Chunk</h4>
                        @if (!string.IsNullOrWhiteSpace(selectedItem.Transcription))
                        {
                            <span class="text-gray-500 text-sm">/@selectedItem.Transcription/</span>
                        }
                    </div>
                    <button type="button" class="btn-close btn-sm" @onclick="ClearDefinition"></button>
                </div>

                @if (!string.IsNullOrWhiteSpace(selectedItem.AiInsight.Translation))
                {
                    <div class="mb-2">
                        <span class="text-success fw-bold">🔤 @selectedItem.AiInsight.Translation</span>
                    </div>
                }

                @if (!string.IsNullOrWhiteSpace(selectedItem.AiInsight.Note))
                {
                    <div class="mb-2 p-2 bg-white rounded border border-blue-100">
                        <small class="text-muted">💡 @selectedItem.AiInsight.Note</small>
                    </div>
                }

                @if (selectedItem.IsCompound && selectedItem.Components != null)
                {
                    <!-- Compound expression: show lemmatized components -->
                    <div class="mt-3 p-2 bg-white rounded border border-blue-100">
                        <div class="d-flex flex-wrap gap-2">
                            @foreach (var component in selectedItem.Components)
                            {
                                <div class="badge bg-secondary component-badge" 
                                     @onclick="(e) => OnComponentClick(component.Lemma, e)"
                                     @onclick:stopPropagation="true">
                                    @component.Lemma
                                    @if (!string.IsNullOrWhiteSpace(component.PartOfSpeech) && false)
                                    {
                                        <span class="ms-1 opacity-75">(<Translate Text="@component.PartOfSpeech" Lang=@AvailableCodes.English/>)</span>
                                    }
                                </div>
                            }
                        </div>
                    </div>
                }
                else if (!string.IsNullOrWhiteSpace(selectedItem.SingleWordPos))
                {
                    <!-- Single word: show POS tag -->
                    <div class="mt-2">
                        <span class="badge bg-primary"><Translate Text="@selectedItem.SingleWordPos" Lang=@AvailableCodes.English/></span>
                    </div>
                }

                @if (string.IsNullOrWhiteSpace(selectedItem.AiInsight.Translation) && 
                     string.IsNullOrWhiteSpace(selectedItem.AiInsight.Note) && 
                     selectedItem.Components == null && 
                     string.IsNullOrWhiteSpace(selectedItem.SingleWordPos))
                {
                    <p class="text-muted small mb-0"><Translate Text="Sem informações adicionais"></Translate></p>
                }
            </div>
        }

        <!-- Main Sentence with Word Blocks -->
        <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-2">
                <Translate Text="Texto em"></Translate> @TargetLanguage?.DisplayName
            </label>
            <LoadingSpinner IsLoading="@isAnalyzing">
                <div class="p-4 bg-gray-50 rounded-lg border border-gray-300">
                    @if (analysisItems.Any())
                    {
                        <div class="flex flex-wrap gap-2">
                            @foreach (var item in analysisItems)
                            {
                                <span @onclick="() => OnItemClick(item)"
                                      class="@GetItemBlockClass(item)"
                                      style="cursor: pointer; display: inline-flex; flex-direction: column; align-items: flex-start;">
                                    <span>@item.AiInsight.Chunk</span>
                                </span>
                            }
                        </div>
                    }
                    else
                    {
                        <p class="text-lg">@analysisText</p>
                    }
                </div>
            </LoadingSpinner>
        </div>

        <!-- Translation -->
        @if (IsApiLive)
        {
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">
                    <Translate Text="Tradução para"></Translate> @Nativelanguage?.DisplayName
                </label>
                <LoadingText IsLoading="@isTranslating" Lines="2">
                    <div class="p-4 bg-gray-50 rounded-lg border border-gray-300">
                        <p class="text-lg">@translatedText</p>
                    </div>
                </LoadingText>
            </div>
        }

        <!-- Action Buttons -->
        <div class="mt-6 flex gap-2">
            <button @onclick="AddToDeck"
                    class="flex-1 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">
                <i class="fa fa-plus me-2"></i>
                <Translate Text="Adicionar ao Deck"></Translate>
            </button>
            <button @onclick="Reset"
                    class="flex-1 px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">
                <i class="fa fa-refresh me-2"></i>
                <Translate Text="Novo Texto"></Translate>
            </button>
        </div>

        <!-- Chunk Statistics -->
        @if (analysisItems.Any())
        {
            <div class="mt-4 p-3 bg-indigo-50 rounded-lg">
                <small class="text-gray-600">
                    <i class="fa fa-info-circle me-1"></i>
                    <Translate Text="Total de chunks"></Translate>: @analysisItems.Count
                    @if (analysisItems.Count(item => !string.IsNullOrWhiteSpace(item.AiInsight.Note)) > 0)
                    {
                        <span class="ms-2">
                            | <Translate Text="Com notas"></Translate>: @analysisItems.Count(item => !string.IsNullOrWhiteSpace(item.AiInsight.Note))
                        </span>
                    }
                </small>
            </div>
        }

        @if (!IsApiLive)
        {
            <div class="mt-4 p-3 bg-yellow-50 rounded-lg border border-yellow-200">
                <small class="text-yellow-800">
                    <i class="fa fa-exclamation-triangle me-1"></i>
                    <Translate Text="API offline - recursos limitados"></Translate>
                </small>
            </div>
        }
    }
</div>

<!-- Definition Tooltip Component -->
<DefinitionTooltip IsVisible="@showComponentTooltip"
                   IsLoading="@isLoadingComponentDef"
                   DefinitionResult="@componentDefinitionResult"
                   X="@tooltipX"
                   Y="@tooltipY"
                   OnClose="@CloseComponentTooltip" />

<style>
    .component-badge {
        cursor: pointer;
        transition: all 0.2s ease;
        user-select: none;
    }

    .component-badge:hover {
        transform: scale(1.05);
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        background-color: #6366f1 !important;
    }

    .component-badge:active {
        transform: scale(0.95);
    }
</style>

@code {
    [Parameter]
    public string? EncodedText { get; set; }

    [Parameter]
    public string? EncodedTranslation { get; set; }

    private string inputText = string.Empty;
    private string analysisText = string.Empty;
    private string translatedText = string.Empty;

    private AnalysisItem? selectedItem;
    private bool isAnalyzing = false;
    private bool isTranslating = false;
    private VocabularyService? vocabularyService;

    // Store all vocabulary tokens from the text
    private List<VocabularyService.Token> allVocabTokens = new();

    // List of analysis items correlating API chunks with POS tokens (ordered)
    private List<AnalysisItem> analysisItems = new();

    private class AnalysisItem
    {
        public LexicalChunk AiInsight { get; set; } = null!;
        public List<VocabularyService.Token> VocabTokens { get; set; } = new();
        public string? Transcription { get; set; }
        public string NormalizedKey => AiInsight.Chunk.Trim().ToLowerInvariant();

        // Convenience properties for display
        public bool IsCompound => VocabTokens.Count > 1;
        public string? SingleWordPos => VocabTokens.Count == 1 ? VocabTokens[0].PartOfSpeech : null;
        public List<VocabularyService.Token>? Components => VocabTokens.Count > 1 ? VocabTokens : null;

        public override bool Equals(object? obj)
        {
            return obj is AnalysisItem item && NormalizedKey == item.NormalizedKey;
        }

        public override int GetHashCode()
        {
            return NormalizedKey.GetHashCode();
        }
    }

    // Component tooltip state
    private bool showComponentTooltip = false;
    private bool isLoadingComponentDef = false;
    private DefinitionResult? componentDefinitionResult = null;
    private double tooltipX = 0;
    private double tooltipY = 0;
    private string currentComponentWord = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        // If text is provided via URL parameter, prepare but don't block rendering
        if (!string.IsNullOrWhiteSpace(EncodedText))
        {
            analysisText = Uri.UnescapeDataString(EncodedText);
            inputText = analysisText;

            // If translation is provided, use it
            if (!string.IsNullOrWhiteSpace(EncodedTranslation))
            {
                translatedText = Uri.UnescapeDataString(EncodedTranslation);
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        // Start analysis after first render to avoid blocking UI
        if (firstRender && !string.IsNullOrWhiteSpace(analysisText))
        {
            await StartAutomaticAnalysis();
        }
    }

    private async Task StartAutomaticAnalysis()
    {
        // Start analysis automatically (non-blocking)
        _ = Task.Run(async () =>
        {
            await AnalyzeText();

        });
        // Translate automatically if API is live and no translation provided
        _ = Task.Run(async () =>
        {
            if (IsApiLive && string.IsNullOrWhiteSpace(translatedText))
            {
                await TranslateText();
            }
        });
    }

    private async Task StartAnalysis()
    {
        if (string.IsNullOrWhiteSpace(inputText))
            return;

        analysisText = inputText;
        await AnalyzeText();

        if (IsApiLive)
        {
            await TranslateText();
        }
    }

    private async Task AnalyzeText()
    {
        isAnalyzing = true;
        selectedItem = null;
        allVocabTokens.Clear();
        analysisItems.Clear();
        await InvokeAsync(StateHasChanged);

        try
        {
            // Initialize vocabulary service and start POS analysis immediately (eager loading)
            vocabularyService = new VocabularyService(TargetLanguageCode);
            var posTask = PerformBatchPosAnalysisAsync(analysisText);
            
            // Check API availability and fetch lexical analysis in parallel with POS
            var isApiAvailable = await ApiService.IsAvailable();

            if (isApiAvailable)
            {
                // Run API analysis in parallel with ongoing POS detection
                var apiTask = ApiService.GetLexicalAnalysisAsync(analysisText, TargetLanguageCode);

                // Wait for both to complete
                await Task.WhenAll(apiTask, posTask);

                var response = await apiTask;

                if (response != null && response.Items != null && response.Items.Any())
                {
                    // Create analysis items correlating API chunks with vocab tokens
                    CorrelateApiChunksWithVocabTokens(response.Items);
                }
                else
                {
                    // Fallback to basic split if API returns empty
                    var basicChunks = CreateBasicChunks();
                    CorrelateBasicChunksWithVocabTokens(basicChunks);
                }
            }
            else
            {
                // API is offline, just wait for POS analysis to complete
                await posTask;
                var basicChunks = CreateBasicChunks();
                CorrelateBasicChunksWithVocabTokens(basicChunks);
            }

            // Load transcriptions after analysis completes
            await LoadTranscriptionsAsync();

            // Preload audio for all chunks after analysis completes
            if (IsApiLive && analysisItems.Any())
            {
                _ = PreloadChunkAudioAsync();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error analyzing text: {ex.Message}");
            var basicChunks = CreateBasicChunks();
            CorrelateBasicChunksWithVocabTokens(basicChunks);
        }
        finally
        {
            isAnalyzing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    /// <summary>
    /// Loads transcriptions for all analysis items
    /// </summary>
    private async Task LoadTranscriptionsAsync()
    {
        try
        {
            // Get transcription provider for the target language
            if (!LanguageServiceFactory.TryGetLanguageService(TargetLanguageCode, out var languageService))
            {
                Console.WriteLine($"No language service found for {TargetLanguageCode}");
                return;
            }

            var transcriptionProviders = languageService.GetTranscriptionProviders();
            var transcriptionProvider = transcriptionProviders?.FirstOrDefault();

            if (transcriptionProvider == null)
            {
                Console.WriteLine($"No transcription provider available for {TargetLanguageCode}");
                return;
            }

            Console.WriteLine($"Loading transcriptions using {transcriptionProvider.ProviderName}");

            // Load transcriptions for each item in parallel
            var transcriptionTasks = analysisItems.Select(async item =>
            {
                try
                {
                    string? transcription;
                    
                    if (item.IsCompound && item.Components != null)
                    {
                        // For compound expressions, get transcription of all lemmas
                        var lemmas = item.Components.Select(c => c.Lemma).Where(l => !string.IsNullOrWhiteSpace(l));
                        transcription = await transcriptionProvider.GetTranscriptionAsync(lemmas);
                    }
                    else
                    {
                        // For single words, transcribe the chunk directly
                        transcription = await transcriptionProvider.GetTranscriptionAsync(item.AiInsight.Chunk);
                    }

                    item.Transcription = transcription;
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error loading transcription for '{item.AiInsight.Chunk}': {ex.Message}");
                }
            });

            await Task.WhenAll(transcriptionTasks);
            
            Console.WriteLine($"Transcriptions loaded for {analysisItems.Count(i => !string.IsNullOrWhiteSpace(i.Transcription))} items");
            
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading transcriptions: {ex.Message}");
        }
    }

    /// <summary>
    /// Preloads audio for all chunks in parallel
    /// </summary>
    private async Task PreloadChunkAudioAsync()
    {
        try
        {
            Console.WriteLine($"Starting audio preload for {analysisItems.Count} chunks");
            
            // Create preload tasks for all unique chunks
            var preloadTasks = analysisItems
                .Select(item => item.AiInsight.Chunk.Trim())
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .Select(chunk => PreloadSingleChunkAudioAsync(chunk))
                .ToList();

            // Execute all preload tasks in parallel
            await Task.WhenAll(preloadTasks);
            
            Console.WriteLine($"Audio preload completed for {preloadTasks.Count} unique chunks");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during audio preload: {ex.Message}");
        }
    }

    /// <summary>
    /// Preloads audio for a single chunk
    /// </summary>
    private async Task PreloadSingleChunkAudioAsync(string chunk)
    {
        try
        {
            // Use the sound service to preload (cache) the audio
            await SoundService.PreloadVoiceClipAsync(chunk, TargetLanguageCode);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error preloading audio for chunk '{chunk}': {ex.Message}");
        }
    }

    private async Task OnItemClick(AnalysisItem item)
    {
        if (item == null)
            return;

        selectedItem = item;
        StateHasChanged();

        // Play audio for the clicked chunk
        if (IsApiLive && !string.IsNullOrWhiteSpace(item.AiInsight.Chunk))
        {
            _ = PlayChunkAudioAsync(item.AiInsight.Chunk);
        }
    }

    private async Task OnComponentClick(string lemma, MouseEventArgs e)
    {
        if (string.IsNullOrWhiteSpace(lemma))
            return;

        // Calculate tooltip position relative to the clicked element
        tooltipX = e.ClientX;
        tooltipY = e.ClientY;

        // Don't reload if clicking the same word
        if (currentComponentWord == lemma && componentDefinitionResult != null)
        {
            showComponentTooltip = !showComponentTooltip;
            StateHasChanged();
            return;
        }

        currentComponentWord = lemma;
        showComponentTooltip = true;
        isLoadingComponentDef = true;
        componentDefinitionResult = null;
        StateHasChanged();

        try
        {
            // Get the first available definition provider
            var definitionProvider = TargetLanguageService.GetDefinitionProviders().FirstOrDefault();
            
            if (definitionProvider != null)
            {
                componentDefinitionResult = await definitionProvider.GetDefinitionsAsync(lemma);
                
                // If no results, create a placeholder
                if (componentDefinitionResult == null)
                {
                    componentDefinitionResult = new DefinitionResult
                    {
                        Word = lemma,
                        ProviderName = definitionProvider.ProviderName,
                        Entries = new List<DefinitionEntry>()
                    };
                }
            }
            else
            {
                // No provider available
                componentDefinitionResult = new DefinitionResult
                {
                    Word = lemma,
                    ProviderName = "N/A",
                    Entries = new List<DefinitionEntry>()
                };
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading component definition for '{lemma}': {ex.Message}");
            componentDefinitionResult = new DefinitionResult
            {
                Word = lemma,
                ProviderName = "Error",
                Entries = new List<DefinitionEntry>()
            };
        }
        finally
        {
            isLoadingComponentDef = false;
            StateHasChanged();
        }
    }

    private void CloseComponentTooltip()
    {
        showComponentTooltip = false;
        StateHasChanged();
    }

    private string GetItemBlockClass(AnalysisItem item)
    {
        var baseClasses = "px-2 py-1 rounded transition-all";

        if (selectedItem != null && selectedItem.NormalizedKey == item.NormalizedKey)
        {
            return $"{baseClasses} bg-indigo-600 text-white font-semibold shadow";
        }

        // Highlight chunks with notes differently
        if (!string.IsNullOrWhiteSpace(item.AiInsight.Note))
        {
            return $"{baseClasses} bg-yellow-100 border border-yellow-400 hover:bg-yellow-200 hover:border-yellow-500";
        }

        return $"{baseClasses} bg-white border border-gray-300 hover:bg-indigo-100 hover:border-indigo-400";
    }

    /// <summary>
    /// Plays audio for a chunk (fire and forget)
    /// </summary>
    private async Task PlayChunkAudioAsync(string chunk)
    {
        try
        {
            await PlayVoiceClip(chunk.Trim(), TargetLanguageCode);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error playing audio for chunk '{chunk}': {ex.Message}");
        }
    }

    private void AddToDeck()
    {
        if (string.IsNullOrWhiteSpace(analysisText))
            return;

        var encodedSource = Uri.EscapeDataString(analysisText);
        string navigationUrl;

        if (!string.IsNullOrWhiteSpace(translatedText))
        {
            var encodedTranslation = Uri.EscapeDataString(translatedText);
            navigationUrl = $"/create-card/{encodedSource}/{encodedTranslation}?redirect=/analysis";
        }
        else
        {
            navigationUrl = $"/create-card/{encodedSource}?redirect=/analysis";
        }

        Navigation.NavigateTo(navigationUrl);
    }

    private void Reset()
    {
        inputText = string.Empty;
        analysisText = string.Empty;
        translatedText = string.Empty;
        selectedItem = null;
        allVocabTokens.Clear();
        analysisItems.Clear();
    }

    private void ClearDefinition()
    {
        selectedItem = null;
    }

    private async Task PerformBatchPosAnalysisAsync(string text)
    {
        try
        {
            if (vocabularyService == null)
            {
                vocabularyService = new VocabularyService(TargetLanguageCode);
            }

            // Analyze the entire text to get all tokens
            allVocabTokens = await vocabularyService.GetVocabWordsWithTagAsync(new[] { text });

            Console.WriteLine($"POS analysis completed: {allVocabTokens.Count} tokens detected");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in batch POS analysis: {ex.Message}");
            allVocabTokens = new List<VocabularyService.Token>();
        }
    }

    private void CorrelateApiChunksWithVocabTokens(List<LexicalChunk> lexicalChunks)
    {
        if (lexicalChunks == null || !allVocabTokens.Any())
            return;

        analysisItems.Clear();
        
        // Track the current position in the original text and token list
        int currentTextIndex = 0;
        int currentTokenIndex = 0;

        foreach (var chunk in lexicalChunks)
        {
            var cleanChunk = chunk.Chunk.Trim();
            
            // Skip chunks that are exclusively punctuation
            if (IsExclusivelyPunctuation(cleanChunk))
            {
                continue;
            }
            
            // Find where this chunk appears in the text starting from current position
            int chunkStartIndex = analysisText.IndexOf(cleanChunk, currentTextIndex, StringComparison.OrdinalIgnoreCase);
            
            if (chunkStartIndex == -1)
            {
                // Chunk not found, try without case sensitivity and with flexible matching
                chunkStartIndex = currentTextIndex;
            }

            int chunkEndIndex = chunkStartIndex + cleanChunk.Length;
            
            var item = new AnalysisItem
            {
                AiInsight = chunk,
                VocabTokens = new List<VocabularyService.Token>()
            };

            // Collect tokens that fall within or overlap with this chunk's text range
            while (currentTokenIndex < allVocabTokens.Count)
            {
                var token = allVocabTokens[currentTokenIndex];
                var tokenText = token.Text.Trim();
                
                // Find where this token appears in the text starting from the chunk start
                int tokenStartIndex = analysisText.IndexOf(tokenText, chunkStartIndex, StringComparison.OrdinalIgnoreCase);
                
                // If token not found or beyond chunk end, we've collected all tokens for this chunk
                if (tokenStartIndex == -1 || tokenStartIndex >= chunkEndIndex)
                {
                    break;
                }
                
                // Token belongs to this chunk
                item.VocabTokens.Add(token);
                currentTokenIndex++;
                
                // Update position to after this token for next search
                chunkStartIndex = tokenStartIndex + tokenText.Length;
            }

            analysisItems.Add(item);

            // Move current text index to the end of this chunk
            currentTextIndex = chunkEndIndex;
        }

        Console.WriteLine($"Correlated {analysisItems.Count} API chunks with vocabulary tokens using index-based approach");
    }

    private void CorrelateBasicChunksWithVocabTokens(List<LexicalChunk> lexicalChunks)
    {
        if (lexicalChunks == null || !allVocabTokens.Any())
            return;

        analysisItems.Clear();

        // Simple correlation: match by text content
        foreach (var chunk in lexicalChunks)
        {
            var cleanChunk = chunk.Chunk.Trim();

            // Skip chunks that are exclusively punctuation
            if (IsExclusivelyPunctuation(cleanChunk))
            {
                continue;
            }

            // Find matching token(s) by text
            var matchingTokens = allVocabTokens
                .Where(t => string.Equals(t.Text.Trim(), cleanChunk, StringComparison.OrdinalIgnoreCase))
                .ToList();

            var item = new AnalysisItem
            {
                AiInsight = chunk,
                VocabTokens = matchingTokens
            };
            
            analysisItems.Add(item);
        }

        Console.WriteLine($"Correlated {analysisItems.Count} basic chunks with vocabulary tokens");
    }

    /// <summary>
    /// Checks if a string consists exclusively of punctuation characters
    /// </summary>
    private bool IsExclusivelyPunctuation(string text)
    {
        if (string.IsNullOrWhiteSpace(text))
            return true;

        // Check if all characters are punctuation or whitespace
        return text.All(c => char.IsPunctuation(c) || char.IsWhiteSpace(c));
    }

    private List<LexicalChunk> CreateBasicChunks()
    {
        return analysisText
            .Split(new[] { ' ', '.', ',', ';', ':', '-', '!', '?', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(w => new LexicalChunk
            {
                Chunk = w,
                Translation = string.Empty,
                Note = string.Empty
            })
            .ToList();
    }

    private async Task TranslateText()
    {
        if (string.IsNullOrWhiteSpace(analysisText))
            return;

        isTranslating = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            translatedText = await ApiService.GetTranslationAsync(
                analysisText,
                TargetLanguageCode,
                NativeLanguageCode
            );
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error translating text: {ex.Message}");
            translatedText = string.Empty;
        }
        finally
        {
            isTranslating = false;
            await InvokeAsync(StateHasChanged);
        }
    }
}
